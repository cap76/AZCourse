[
["index.html", "Classical approaches to Machine Learning 1 About the course 1.1 Prerequisites 1.2 Schedule 1.3 Github 1.4 Google docs interactive Q&amp;A 1.5 License 1.6 Contact 1.7 Colophon", " Classical approaches to Machine Learning Chris Penfold 2021-12-21 1 About the course Machine learning describes a series of data-driven algorithmic approaches that simulate the “learning without being explicitly programmed” paradigm. These methods are particularly useful when limited information is available about the structure or properties of a dataset; also, real-world data rarely follows a well-defined mathematical distribution (due to technical variation in measurements, noise, etc) – assumption-free models offer flexibility for this type of input with the side effects of underlying characteristics of the dataset (e.g. through feature selection). The term “Machine Learning” encompasses a broad range of approaches in data analysis with wide applicability across biological sciences. Lectures will introduce commonly used approaches, provide insight into their theoretical underpinnings and illustrate their applicability and limitations through examples and exercises. During the practical sessions students will apply the algorithms to real biological data-sets using the R language and RStudio environment. All code utilised during the course will be available to participants. 1.1 Prerequisites Some familiarity with R would be helpful. 1.2 Schedule Time Data Module 14:00 – 15:00 30/11/21 Linear regression / linear models 15:00 – 16:30 30/11/21 Logistic regression 16:30 – 17:00 30/11/21 Review and questions 14:00 – 15:00 2/12/21 Artificial Neural Networks 15:00 – 16:30 2/12/21 Convolutional neural nets and beyond 16:30 – 17:00 2/12/21 Review and questions 1.3 Github The github reposotory for Classical approaches to Machine Learning containing code, datasets and lectures is availabile here. The html textbook is found in docs/index.html. Individual chapters (files ending .Rmd) can be opened in RStudio as interactive markdown files. 1.4 Google docs interactive Q&amp;A Clicking the link [here]{https://docs.google.com/document/d/1fDiVihZWsSiFKllsANFGd_jV3SK6jlq4IOj5dEPtQTM/edit?usp=sharing} takes you to the interactive Q&amp;A document, where you can ask any questions you might have. 1.5 License GPL-3 1.6 Contact If you have any comments, questions or suggestions about the material, please contact Chris Penfold. 1.7 Colophon This book was produced using the bookdown package (Xie 2017), which was built on top of R Markdown and knitr (Xie 2015). References "],
["intro.html", "2 Introduction", " 2 Introduction In this workbook, we cover two themes. We begin in chapter 4 with linear regression and logistic regression. Here we will explore how to use these statistical methods in the context of machine learning. The excercises are based on a plant infection dataset. We will see how regression models of different complexity can be fit to the dataset, and how held out data can be used to choose the best model. After this, we will see how logistic regression approaches can be used to pick out marker genes that indicate infected status. In chapter 5 we introduce the concepts of neural networks. We demonstrate how neural networks can be built using the {kerasR} package for regression applications. Later we introduce Convolutional Neural Networks (CNN) and see how they can be used for image recognition applications. In this chapter we attempt to build an algorithm capable of recognising a well known cartoon characer in a se of images. Finally, we briefly discuss how these basic approaches can be built into more complex algorithms. "],
["installation.html", "3 Installation", " 3 Installation For the second half of this workbook we will make use of an R wrapper for keras (a Python package, which itself backends to Tensorflow). To be able to do so, we will have to install Python (I have tested on Python 3.9), tensorflow and keras. Python can be installed from here. When installing Python there will be an option to add the package to the system path: choosing to do so will make things a lot easier when it comes to running the backend in R. Depending on your operating system, it may also be necessary to allow long long path names (this seems to be a Windows option). If you do not allow long path names, tensorflow may not install. If you did not enable Long paths, this will have to be set manually, and instructions can be found on Google by searching: How do I enable enabled Win32 long paths? Once Python is installed, it will be necessary to idenity how to call it from the Terminal/Command Line. Usually, if you have addedd the path on installation this will be the Python version i.e., I can launch the Python3.9 from Terminal/Command Line via: python3.9 This will usually work if you have multiple versions installed, but sometimes names can be mixed up. For example, I installed Python3.9 and Python 3.6 on a Windows machine, and could call the latter with python3 but had to call: python to open Python3.6. The version of Python you have launched will usually be displayede on launch. Once you've identified how to launch the specific version of Python you want, the next step is to install tensorflow to that version. Sometimes when you have multuple installs it can be difficult to ensure the correct pip is called. To avoid this confusion, you can be explicit: python3.9 -m pip install tensorflow You can be even more specific by selecting a version of tensorflow: python3.9 -m pip install tensorflow==2.7.0 Tensorflow 2.2.0 is the version I have installed on my machine. Keras has already been incorporated into the most recent versions of tensorflow, and so it may not be necesary to install a seperate version of keras. For debugging purposes I did not install keras. You can check things have installed within Python by launching a python instance and loading the packages: python3.9 Then from within Python import tensorflow as tf import keras tf.version.VERSION keras.__version__ exit() Finally, we will open Rstudio, install reticulate, set the version of Python to use, and install the R backend to keras. install.packages(&quot;reticulate&quot;) library(reticulate) use_python(&quot;Python3.9&quot;) install.packages(&quot;keras&quot;) At this stage you should now be ready to run Keras in R. More information about Python installations can be found at the links below. Installing Python Linux Installing Python for Mac Installing Python via Conda Installing Tensorflow Installing Keras "],
["logistic-regression.html", "4 Linear regression and logistic regression 4.1 Regression 4.2 Resources", " 4 Linear regression and logistic regression Supervised learning refers to the general task of identifying how a set of annotated input data maps to a set of outcomes. In other words, it's about learning functions from a labelled set of data, and using those functions for prediction. The labelled data typically consists of a matched pair of observations \\(\\{\\mathbf{X},\\mathbf{y}\\}\\), where \\(\\mathbf{X}\\) (the input variables) is usually a matrix of (real-valued) explanatory variables, with \\(\\mathbf{X}_i\\) denoting the \\(i\\)th column which contains observations for the \\(i\\)th variable, and \\(\\mathbf{y} = (y_1,\\ldots,y_n)^\\top\\) (the output variable) denotes a vector of observations for a variable of interest (the input variables need not be real values vectors, and could instead represent any measurement including graphs, text etc.). In general, the input variables are often easier or cheaper to measure, but it's the output variables that we're really interested in. Depending on the nature of the output variable, supervised learning is generally split into regression and classification tasks. Within a regression setting, we usually aim to identify how the input variables map to the (continuous-valued) output variable(s). A simple example would involve measuring the population size of a bacterial culture, \\(\\mathbf{y} = (N_1,\\ldots,N_n)^\\top\\), at a set of time points, \\(\\mathbf{X} = (t_1,\\ldots,t_n)^\\top\\), and learning the function that maps from \\(\\mathbf{X}\\) to \\(\\mathbf{y}\\). Doing so should reveal something about the physical nature of the system, such as identifying the existence of distinct phases of growth. Correctly identifying these functions would also allow us to predict the output variable, \\(\\mathbf{y}^* = (N_i^*,\\ldots,N_k^*)^\\top\\), at a new set of times, \\(\\mathbf{X}^* = (t_i,\\ldots,t_k)^\\top\\). Classification algorithms, on the other hand, deal with discrete-valued outputs. Here each observation in \\(\\mathbf{y} = (y_1,\\ldots,y_n)\\) can take on only a finite number of values. For example, we may have a measurement that indicates &quot;infected&quot; versus &quot;uninfected&quot;, which can be represented in binary, \\(y_i \\in [0,1]\\). More generally we have data that falls into \\(K\\) classes e.g., &quot;group 1&quot; through to &quot;group K&quot;. As with regression, the aim is to identify how the (potentially continuous-valued) input variables map to the discrete set of class labels, and ultimately, assign labels to a new set of observations. Notable examples would be to identify how the expression levels of particular set of marker genes are predictive of a discrete phenotype. Although we do not specifically addrerss classification in this section, towards the end we will cover a regression model that can be used to perform binary classification from continuous values input data: logistic regression. Logistic regression, itself, is not a classification algorithm per se, but it can be used in such a context, as we will show. In section 4.1 we briefly recap linear regression. As an example, we demonstrate the use of regression to predict gene expression values as a function of time, and how this can be used to inform us about the nature of the data, and as a way to make decisions about whether there are changes in gene expression over time.Then, in section 4.1.4 we introduce logistic regression (section 4), and demonstrate how such approaches can be used to predict pathogen infection status in Arabidopsis thaliana, again based on gene expression levels. By doing so we identify key marker genes indicative of pathogen growth. 4.1 Regression In this section, we will recap our understanding of regression. To do so will make use of an existing dataset which captures the gene expression levels in the model plant Arabidopsis thaliana following innoculation with Botrytis cinerea (Windram et al. 2012), a necrotrophic pathogen considered to be one of the most important fungal plant pathogens due to its ability to cause disease in a range of plants. Specifically this dataset is a time series measuring the gene expression of 100 or so genes in Arabidopsis leaves following inoculation with Botrytis cinerea over a \\(48\\) hour time window, with observations taken at \\(2\\) hour intervals. Whilst this example is distinctly biological in motivation the methods we discuss should be general and applicable to other collections of time series data, and it may be helpful to instead think of things in terms of input variables and output variables. The dataset is available from GEO (GSE39597) but a pre-processed version has been deposited in the {data} folder. This pre-processed data contains the expression levels of a set of \\(163\\) marker genes in tab delimited format. The fist row contains gene IDs for the marker genes (the individual input variables). Column \\(2\\) contains the time points of observations, with column \\(3\\) containing a binary indication of infection status evalutated as \\(0\\) or \\(1\\) according to wether there was a detectable presence of Botrytis cinerea tubulin protein. All subsequent columns indicate (\\(\\log_2\\)) normalised Arabidopsis gene expression values from microarrays (V4 TAIR V9 spotted cDNA array). The expression dataset itself contains two time series: the first \\(24\\) observations represent measurements of Arabidopsis gene expression in a control time series (uninfected), from \\(2h\\) through \\(48h\\) at \\(2\\)-hourly intervals, and therefore capture dynamic aspects natural plant processes, including circadian rhythms; the second set of \\(24\\) observations represents an infected dataset, again commencing \\(2h\\) after inoculation with Botyris cinerea through to \\(48h\\). Within this section our output variable will typically be the expression level of a particular gene of interest, denoted \\(\\mathbf{y} =(y_1,\\ldots,y_n)^\\top\\), with the explanatory variable being time, \\(\\mathbf{X} =(t_1,\\ldots,t_n)^\\top\\). We can read the dataset into {R} as follows: D &lt;- read.csv(file = &quot;data/Arabidopsis/Arabidopsis_Botrytis_transpose_3.csv&quot;, header = TRUE, sep = &quot;,&quot;, row.names=1) D &lt;- read.csv(file = &quot;data/Arabidopsis/Arabidopsis_Botrytis_pred_transpose_3.csv&quot;, header = TRUE, sep = &quot;,&quot;, row.names=1) We can also extract out the names of the variables (gene names), and the unique vector of measurment times. For the control experiment this would look like: genenames &lt;- colnames(D) Xs &lt;- D$Time[1:96] whilst for the treatment, it would be genenames &lt;- colnames(D) Xs2 &lt;- D$Time[97:nrow(D)] Exercise 1.1. Plot the gene expression profiles to familiarise yourself with the data. No, really, plot the data. This is always the first thing you should be doing with your datasets - look at them. The general aim of this module is to give you hands on experience with linear and logistic regression and cover a number of other concepts from machine learning. The main points are: Do you understand the data? A priority before doing any ML should be to look, interrogate, and understand the data. What is the data. Look at the data. Repeat 1-3 a few more times. Once more for luck, look at the data. Once we begin to understand the data, we will have a better grasp of what we are doing and what ML approaches to take. In the first example we will start with some linear regression. We will explore more complicated forms of regression. We will get an idea of how to partition data into training and test sets, and how in doing so we may distinguish between different types of models. We will start to get an intuition for how regression tasks may be used to predict values an new locations, and why choosing the right kind of model is important. 4.1.1 Linear regression The plant dataset consists of 8 time series (4 replicated time series from a control &quot;mock infection&quot; and \\(4\\) time series from an Botrytis-inoculated plant). Each time series contains 24 time points, over \\(48\\) hours at \\(2\\) hourly intervals. Now that we have an idea about what our dataset is, we can start to do something with it. Here we have a time series (a number of time-series, in fact), so we may, at some point, want to develop a models of how specific genes are changing over time: this would allow us to predict what gene expression might be doing at some point in the futurer (forecasting) or uncover something about the physical nature of the system i.e., what kind of function best describes the behaviour. Recall that one of the simplest forms of regression, linear regression, assumes that the variable of interest, \\(y\\), depends on an explanatory variable, \\(x\\), via: \\(y = m x + c.\\) For a typical set of data, we have a vector of observations, \\(\\mathbf{y} = (y_1,y_2,\\ldots,y_n)\\) with a corresponding set of explanatory variables. For now we can assume that the explanatory variable is scalar, for example time (in hours), such that we have a set of observations, \\(\\mathbf{X} = (t_1,t_2,\\ldots,t_n)\\). Using linear regression we aim to infer the parameters \\(m\\) and \\(c\\), which will tell us something about the relationship between the two variables, and allow us to make predictions at a new set of locations, \\(\\mathbf{X}*\\). Within {R}, linear regression can be implemented via the {lm} function. In the example below, we perform linear regression for the gene expression of AT2G28890 as a function of time, using \\(3\\) of the \\(4\\) infection time series (saving the fourth for validation): linmod &lt;- lm(AT2G28890~Time, data = D[4*24 +1:7*24,]) within this snippet of code, the {lm} function has analytically identified the gradient and offset (\\(m\\) and \\(c\\) parameters) based upon all 24 time points (4 replicates), and we can take a look at those parameters via {linmod$oefficients}. In general, it is not a very good idea to infer parameters using all of the data. Doing so would leave no way to evaluate for overfitting. Ideally, we wish to partition the dataset into a training set, and an evaluation set, with parameters evaluated on the training set, and model performance summarised over the evaluation set. We can of course partition this dataset manually, or use a package to do so. In the previous workshops we saw how {caret} machine learning wrapper could be used to easily specify various partitions of the dataset. Linear regression is implemented within the {caret} package, allowing us to make use of these utilities. In fact, within {caret}, linear regression is performed by calling the function {lm}. In the example, below, we perform linear regression for gene AT2G28890, and predict the expression pattern for that gene using the {predict} function: library(caret) ## Warning: package &#39;caret&#39; was built under R version 3.5.2 ## Loading required package: lattice ## Warning: package &#39;lattice&#39; was built under R version 3.5.2 ## Loading required package: ggplot2 library(mlbench) library(ggplot2) set.seed(1) geneindex &lt;- which(genenames==&quot;AT2G28890&quot;) startind &lt;- (4*24)+1 endind &lt;- 7*24 lrfit &lt;- train(y~., data=data.frame(x=D[startind:endind,1],y=D[startind:endind,geneindex] ), method = &quot;lm&quot;) predictedValues&lt;-predict(lrfit) A summary of the model, including parameters, can be printed out to screen using the {summary} function: summary(lrfit) ## ## Call: ## lm(formula = .outcome ~ ., data = dat) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.3862 -0.3787 0.0814 0.4267 1.7164 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.380430 0.201695 51.466 &lt; 2e-16 *** ## x -0.062616 0.007058 -8.872 4.54e-13 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.8291 on 70 degrees of freedom ## Multiple R-squared: 0.5293, Adjusted R-squared: 0.5226 ## F-statistic: 78.71 on 1 and 70 DF, p-value: 4.543e-13 Conveniently, in cases where we do not specify a split in the data, {caret} will split these by default settings, and can look at various metrics on the held out data in {lrfit$results}. We can make predictions at new points (for example if we are interested in forecasting at some time in the future) by specifying a new set of time points over which to make a prediction: newX &lt;- seq(0,48,by=0.5) forecastValues&lt;-predict(lrfit,newdata = data.frame(x=newX) ) plot(D[startind:endind,1],D[startind:endind,geneindex],type=&quot;p&quot;,col=&quot;black&quot;,ylim=c(min(D[,geneindex])-0.2, max(D[,geneindex]+0.2)),main=genenames[geneindex]) points(newX,forecastValues,type=&quot;l&quot;,col=&quot;black&quot;) We can also take a look at predictions in the held-out \\(4\\)th replicate: newX &lt;- D[169:192,1] forecastValues&lt;-predict(lrfit,newdata = data.frame(x=newX) ) residuals &lt;- forecastValues - D[169:192,geneindex] plot(residuals, type=&quot;p&quot;,col=&quot;black&quot;,main=genenames[geneindex]) Let's also fit a linear model to the control dataset (again only using 3 datasets), and plot the inferred results alongside the observation data for both fitted models: newX &lt;- seq(0,48,by=0.5) lrfit2 &lt;- train(y~., data=data.frame(x=D[1:72,1],y=D[1:72,geneindex]), method = &quot;lm&quot;) predictedValues2 &lt;- predict(lrfit2, newdata = data.frame(x=newX)) predictedValues&lt;-predict(lrfit,newdata = data.frame(x=newX) ) plot(D[1:72,1],D[1:72,geneindex],type=&quot;p&quot;,col=&quot;black&quot;,ylim=c(min(D[,geneindex])-0.2, max(D[,geneindex]+0.2)),main=genenames[geneindex]) points(D[97:168,1],D[97:168,geneindex],type=&quot;p&quot;,col=&quot;red&quot;) points(newX,predictedValues,type=&quot;l&quot;,col=&quot;red&quot;) points(newX,predictedValues2,type=&quot;l&quot;,col=&quot;black&quot;) Whilst the above model appeared to do reasonably well at capturing the general trends in the dataset, if we take a closer look at the control data (in red), you may notice that, visually, there appears to be more structure to the data than indicated by the model fit. One thing we can do is take a look at the residuals fo each model: if there is structure in the residuals, it would suggest the model is not capturing the full richness of the model. Indeed, if we look AT2G28890 up on CircadianNET, we will see it is likely circadian in nature (\\(p&lt;5\\times10^{-5}\\)) suggesting there may be some rhythmicity to it. To better accommodate the complex nature of this data we may need something more complicated. 4.1.2 Polynomial regression In general, linear models will not be appropriate for a large variety of datasets, particularly when the variables of interest are nonlinear. We can instead try to fit more complex models, such as a quadratic function, which has the following form: \\(y = m_1 x + m_2 x^2 + c,\\) where \\(m = [m_1,m_2,c]\\) represent the parameters we're interested in inferring. An \\(n\\)th-order polynomial has the form: \\(y = \\sum_{i=1}^{n} m_i x^i + c.\\) where \\(m = [m_1,\\ldots,m_n,c]\\) are the free parameters. Within {R} we can infer more complex polynomials to the data using the {lm} package by calling the {poly} function when specifying the symbolic model. In the example below we fit a \\(3\\)rd order polynomial (the order of the polynomial is specified via the {degree} variable): lrfit3 &lt;- lm(y~poly(x,degree=3), data=data.frame(x=D[1:72,1],y=D[1:72,geneindex])) We can do this within {caret}: in the snippet, below, we fit \\(3\\)rd order polynomials to the control and infected datasets, and plot the fits alongside the data. lrfit3 &lt;- train(y~poly(x,degree=3), data=data.frame(x=D[1:72,1],y=D[1:72,geneindex]), method = &quot;lm&quot;) lrfit4 &lt;- train(y~poly(x,degree=3), data=data.frame(x=D[97:168,1],y=D[97:168,geneindex]), method = &quot;lm&quot;) plot(D[97:168,1],D[97:168,geneindex],type=&quot;p&quot;,col=&quot;black&quot;,ylim=c(min(D[,geneindex])-0.2,max(D[,geneindex]+0.2)),main=genenames[geneindex]) points(D[1:72,1],D[1:72,geneindex],type=&quot;p&quot;,col=&quot;red&quot;) newX &lt;- seq(0,48,by=0.5) predictedValues&lt;-predict(lrfit3,newdata = data.frame(x=newX) ) predictedValues2 &lt;- predict(lrfit4, newdata = data.frame(x=newX)) points(newX,predictedValues,type=&quot;l&quot;,col=&quot;red&quot;) points(newX,predictedValues2,type=&quot;l&quot;,col=&quot;black&quot;) Note that, by eye, the fit appears to be a little better than for the linear regression model. Well, maybe! We can quantify the accuracy of the models by looking at the root-mean-square error (RMSE) on the hold-out data (cross validation), defined as: \\(\\mbox{RMSE} = \\sqrt{\\sum_{i=1}^n (\\hat{y_i}-y_i)^2/n}\\) where \\(\\hat{y_i}\\) is the predicted value (model prediction) and \\(y_i\\) the observed value of the \\(i\\)th (held out) datapoint. What happens if we fit a much higher order polynomial? Try fitting a polynomial with degree \\(d = 12\\) and plotting the result. As we increase the model complexity the fit appears to match perfectly well in the training set, but becomes completely useless for prediction. We are overfitting! This is why we use held out data, so that we can evaluate, empirically, when a model is useful, or when it is simply memorising the training set. Exercise 1.2. Using your gene of interest explore the model complexity i.e., try fitting polynomial models of increasing complexity. Plot the RMSE on the test sets as a function of degree. Which model fits best? 4.1.3 Distributions of fits In the previous section we explored fitting a polynomial function to the data. Recall that we can fit a \\(4\\)th order polynomial to the control datasets as follows: lrfit3 &lt;- lm(y~poly(x,degree=4), data=data.frame(x=D[1:72,1],y=D[1:72,geneindex])) plot(D[1:72,1],D[1:72,geneindex],type=&quot;p&quot;,col=&quot;black&quot;,ylim=c(min(D[,geneindex])-0.2, max(D[,geneindex]+0.2)),main=genenames[geneindex]) newX &lt;- seq(0,48,by=0.5) predictedValues&lt;-predict(lrfit3,newdata = data.frame(x=newX) ) lines(newX,predictedValues,type=&quot;l&quot;,col=&quot;red&quot;) It looks reasonable, but how does it compare to the following shown in blue? lrfit4 &lt;- lrfit3 lrfit4$coefficients &lt;- lrfit4$coefficients + 0.1*matrix(rnorm(length(lrfit4$coefficients)),length(lrfit4$coefficients)); pred1&lt;-predict(lrfit4, data=data.frame(x=D[1:24,1],y=D[1:24,geneindex])) plot(D[1:72,1],D[1:72,geneindex],type=&quot;p&quot;,col=&quot;black&quot;,ylim=c(min(D[,geneindex])-0.2, max(D[,geneindex]+0.2)),main=genenames[geneindex]) newX &lt;- seq(0,48,by=0.5) predictedValues&lt;-predict(lrfit3,newdata = data.frame(x=newX) ) predictedValues2&lt;-predict(lrfit4,newdata = data.frame(x=newX) ) lines(newX,predictedValues,type=&quot;l&quot;,col=&quot;red&quot;) lines(newX,predictedValues2,type=&quot;l&quot;,col=&quot;blue&quot;) Our new fit was generated by slightly perturbing the optimised parameters via the addition of a small amount of noise. We can see that the new fit is almost as good, and will have a very similar SSE[^This should give us some intuition on the notion of over-fitting. For example, if we make a small perturbation to the parameters of a simpler model, the function will not change all that much; on the other hand, if we made a small perturbation to the parameters of a more complex polynomial, the function may look drastically different. To explain the data with the more complex model would therefore require very specific sets of parameters]. In general, inferring a single fit to a model is prone to overfitting. A much better approach is to instead fit a distribution over fits. We can generate samples from a linear model using the {coef} function. To do so we must use the {lm} function directly, and not via the {caret} package. library(&quot;arm&quot;) ## Loading required package: MASS ## Warning: package &#39;MASS&#39; was built under R version 3.5.2 ## Loading required package: Matrix ## Warning: package &#39;Matrix&#39; was built under R version 3.5.2 ## Loading required package: lme4 ## Warning: package &#39;lme4&#39; was built under R version 3.5.2 ## ## arm (Version 1.12-2, built: 2021-10-15) ## Working directory is /Users/christopherpenfold/Desktop/AZMachineLearning/AZCourseV2 lrfit4 &lt;- lm(y~poly(x,degree=4), data=data.frame(x=D[1:72,1],y=D[1:72,geneindex])) simulate &lt;- coef(sim(lrfit4)) paramsamp &lt;- head(simulate,10) This will sample model parameters that are likely to explain the dataset. In this case we have produced \\(10\\) different sets of sample parameters. In the code, below, we plot those \\(10\\) sample polynomials: plot(D[1:72,1],D[1:72,geneindex],type=&quot;p&quot;,col=&quot;black&quot;,ylim=c(min(D[,geneindex])-0.2, max(D[,geneindex]+0.2)),main=genenames[geneindex]) for (i in c(1,2,3,4,5,6,7,8,9,10)){ lrfit4$coefficients &lt;- paramsamp[i,] pred1&lt;-predict(lrfit4, newdata = data.frame(x=newX) ) lines(newX,pred1,type=&quot;l&quot;,col=&quot;red&quot;) } 4.1.4 Logistic regression The type of linear regression models we've been using up to this point deal with real-valued observation data, \\(\\mathbf{y}\\), and are therefore not appropriate for classification. To deal with cases where \\(\\mathbf{y}\\) is a binary outcome, we instead have to think of different models. Logistic regression is one example which can be used to model data in which there is a general transition from one state to another as a function of the input variable e.g., where gene expression levels might predict disease state, with lower levels indicating disease-free, and higher-levels indicating a diseased state. Logistic regression does not perform classification per se, but instead models the probability of a successful event (e.g., a \\(1\\)). As probability is a real-valued number (between \\(0\\) and \\(1\\)), technically this remains a form of regression. However, we can logistic regression to make classifications by setting thresholds on the probabilities i.e., if we decide everything with \\(p\\ge 0.5\\) is a success (\\(1\\)), and everything below is a \\(0\\). Another way to think about linear regression is that we are fitting a linear model to the logit (natural log) of the log-odds ratio: \\(\\ln \\biggl{(}\\frac{p(x)}{1-p(x)}\\biggr{)} = c + m_1 x_1.\\) Although this model is not immediately intuitive, if we solve for \\(p(x)\\) we get: \\(p(x) = \\frac{1}{1+\\exp(-c - m_1 x_1)}\\). We have thus specified a function that indicates the probability of success for a given value of \\(x\\) e.g., \\(P(y=1|x)\\). In general can think of our data as a being a sample from a Bernoulli trial, and can therefore write down the likelihood for a set of observations \\({\\mathbf{X},\\mathbf{y}}\\): \\(\\mathcal{L}(c,m_1) = \\prod_{i=1}^n p(x_i)^{y_i} (1-p(x_i)^{1-y_i})\\). Unlike linear regression, these models do not admit a closed form solution, but can be solved iteratively via maximum likelihood. That is by finding the values \\((c,m_1)\\) that return the greatest value of \\(\\mathcal{L}(c,m_1)\\). Within {caret}, logistic regression can applied using the {glm} function. To illustate this we will again make use of our plant dataset. Recall that the second column represents a binary variable indicative of infection status e.g., population growth of the Botrytis cinerea pathogen indicated by observable Botrytis tubulin. In the excercises, below, we will use logistic regression to learn a set of markers capable of predicting infection status. To begin with, let's see if time is informative of infection status: library(pROC) ## Warning: package &#39;pROC&#39; was built under R version 3.5.2 ## Type &#39;citation(&quot;pROC&quot;)&#39; for a citation. ## ## Attaching package: &#39;pROC&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## cov, smooth, var library(ROCR) ## Loading required package: gplots ## ## Attaching package: &#39;gplots&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## lowess options(warn=-1) mod_fit &lt;- train(y ~ ., data=data.frame(x = D$Time, y = as.factor(D$Class)), method=&quot;glm&quot;, family=&quot;binomial&quot;) To make things easier, for model evaluation, we will load in a second (related) dataset, containing a new set of observations not seen by the model, and predict infection status on this held out data. Dpred &lt;- read.csv(file = &quot;data/Arabidopsis/Arabidopsis_Botrytis_transpose_3.csv&quot;, header = TRUE, sep = &quot;,&quot;, row.names=1) prob &lt;- predict(mod_fit, newdata=data.frame(x = Dpred$Time, y = as.factor(Dpred$Class)), type=&quot;prob&quot;) pred &lt;- prediction(prob$`1`, as.factor(Dpred$Class)) To evaluate how well the algorithm has done, we can calculate a variety of summary statistics. For example the number of true positives, true negatives, false positives, and false negatives. A useful summary is to plot the ROC curve (false positive rate versus true positive rate) and calculate the area under the curve. Recall that for a perfect algorithm the area under this curve (AUC) will be equal to \\(1\\), whereas random assignment would give an area of \\(0.5\\). In the example below, we will calculate the AUC for a logistic regression model: perf &lt;- performance(pred, measure = &quot;tpr&quot;, x.measure = &quot;fpr&quot;) plot(perf) auc &lt;- performance(pred, measure = &quot;auc&quot;) auc &lt;- auc@y.values[[1]] auc ## [1] 0.6111111 Okay, so a score of \\(0.61\\) is certainly better than random, but not particularly good. This is perhaps not surprising, as half the time series (the control) is uninfected over the entirety of the time series, whilst in the second times series Botrytis is able to infect from around time point 8 onward. The slightly better than random performance therefore arises due the slight bias in the number of instances of each class. Indeed, if we plot infection status vs time, we should be able to see why the model fails to be predictive. In the example below, we instead try to regress infection status against individual gene expression levels. The idea is to identify genes that have expression values indicative of Botrytis infection: marker genes. aucscore &lt;- matrix(rep(0, 164), 1, 164) for (i in seq(3,164)){ mod_fit &lt;- train(y ~ ., data=data.frame(x = D[,i], y = as.factor(D$Class)), method=&quot;glm&quot;, family=&quot;binomial&quot;) prob &lt;- predict(mod_fit, newdata=data.frame(x = Dpred[,i], y = as.factor(Dpred$Class)), type=&quot;prob&quot;) pred &lt;- prediction(prob$`1`, as.factor(Dpred$Class)) perf &lt;- performance(pred, measure = &quot;tpr&quot;, x.measure = &quot;fpr&quot;) auc &lt;- performance(pred, measure = &quot;auc&quot;) aucscore[i] &lt;- auc@y.values[[1]] } plot(aucscore[1,3:ncol(aucscore)],ylab=&quot;AUC&quot;,xlab=&quot;gene index&quot;) We note that, several genes in the list appear to have AUC scores much greater than \\(0.6\\). We can take a look at some of the genes with high predictive power: genenames[which(aucscore&gt;0.8)] ## [1] &quot;AT1G06510&quot; &quot;AT1G13030&quot; &quot;AT1G14920&quot; &quot;AT1G25490&quot; &quot;AT1G29990&quot; &quot;AT1G30860&quot; ## [7] &quot;AT1G32230&quot; &quot;AT1G45145&quot; &quot;AT1G54060&quot; &quot;AT1G63860&quot; &quot;AT1G67170&quot; &quot;AT1G69690&quot; ## [13] &quot;AT2G04740&quot; &quot;AT2G21380&quot; &quot;AT2G27480&quot; &quot;AT2G28890&quot; &quot;AT2G34710&quot; &quot;AT2G35500&quot; ## [19] &quot;AT2G38750&quot; &quot;AT2G41350&quot; &quot;AT2G44950&quot; &quot;AT2G45660&quot; &quot;AT3G02150&quot; &quot;AT3G06720&quot; ## [25] &quot;AT3G09630&quot; &quot;AT3G09980&quot; &quot;AT3G11590&quot; &quot;AT3G13720&quot; &quot;AT3G16310&quot; &quot;AT3G21490&quot; ## [31] &quot;AT3G25710&quot; &quot;AT3G44720&quot; &quot;AT3G48150&quot; &quot;AT3G49570&quot; &quot;AT3G50910&quot; &quot;AT3G54170&quot; ## [37] &quot;AT3G60600&quot; &quot;AT3G61790&quot; &quot;AT4G00710&quot; &quot;AT4G00980&quot; &quot;AT4G02150&quot; &quot;AT4G04020&quot; ## [43] &quot;AT4G16380&quot; &quot;AT4G17710&quot; &quot;AT4G19700&quot; &quot;AT4G25200&quot; &quot;AT4G26110&quot; &quot;AT4G26450&quot; ## [49] &quot;AT4G28640&quot; &quot;AT4G32190&quot; &quot;AT4G32570&quot; &quot;AT4G34710&quot; &quot;AT4G35580&quot; &quot;AT4G36970&quot; ## [55] &quot;AT4G39050&quot; &quot;AT5G02150&quot; &quot;AT5G11980&quot; &quot;AT5G19480&quot; &quot;AT5G19990&quot; &quot;AT5G20000&quot; ## [61] &quot;AT5G22630&quot; &quot;AT5G24660&quot; &quot;AT5G25070&quot; &quot;AT5G42980&quot; &quot;AT5G43700&quot; &quot;AT5G50010&quot; ## [67] &quot;AT5G51110&quot; &quot;AT5G51910&quot; &quot;AT5G56250&quot; &quot;AT5G56290&quot; &quot;AT5G56950&quot; &quot;AT5G57210&quot; ## [73] &quot;AT5G59670&quot; &quot;AT5G61390&quot; &quot;AT5G66200&quot; &quot;AT5G66560&quot; Unsurprisingly, among these genes we see a variety whose proteins are known to be targeted by various pathogen effectors, and are therefore directly implicated in the immune response (Table 1). Gene Effector AT3G25710 ATR1_ASWA1 AT4G19700 ATR13_NOKS1 AT4G34710 ATR13_NOKS1 AT4G39050 ATR13_NOKS1 AT5G24660 ATR13_NOKS1 AT4G00710 AvrRpt2_Pto JL1065_CatalyticDead AT4G16380 HARXL44 AT2G45660 HARXL45 AT5G11980 HARXL73 AT2G35500 HARXLL445 AT1G67170 HARXLL470_WACO9 AT4G36970 HARXLL470_WACO9 AT5G56250 HARXLL470_WACO9 AT3G09980 HARXLL516_WACO9 AT5G50010 HARXLL60 AT3G44720 HARXLL73_2_WACO9 AT5G22630 HARXLL73_2_WACO9 AT5G43700 HopH1_Psy B728A Table 1: Genes predictive of infection status of Botrytis cinerea whose proteins are targeted by effectors of a variety of pathogens Let's take a look at what the data looks like. In this case we plot the training data labels and the fit from the logistic regression i.e., \\(p(\\mathbf{y}=1|\\mathbf{x})\\): bestpredictor &lt;- which(aucscore==max(aucscore))[1] best_mod_fit &lt;- train(y ~., data=data.frame(x = D[,bestpredictor], y = as.factor(D$Class)), family=&quot;binomial&quot;, method=&quot;glm&quot;) plot(Dpred[,bestpredictor],Dpred$Class,xlab=genenames[bestpredictor],ylab=&quot;Class&quot;) lines(seq(min(Dpred[,bestpredictor]),max(Dpred[,bestpredictor]),length=200),predict(best_mod_fit,newdata=data.frame(x = seq(min(Dpred[,bestpredictor]),max(Dpred[,bestpredictor]),length=200)),type=&quot;prob&quot;)[,2]) We can see from this plot that the level of AT4G26450 appears to be highly predictive of infection status. When AT4G26450 is lowly expressed, its almost certain that the Botrytis cinerea has gained a foothold; whether this is causal or not, we cannot say, but it is almost certainly a good marker. Linear regression and logistic regression represent useful tools for dissecting relationships among variables, and are frequently used as tools to interpret complex datasets. There are some cases where linear approaches may not work so well, however. To illustrate this we will construct an artificial dataset in which low expression levels of a gene indicates no infection, with moderate levels indicating infection; very high levels of the gene, however, do not indicate infected status, but might only arise artificially, due to e.g., inducible overexpression. For this dataset very high levels are thus labeled as uninfected. Below we construct this in silico dataset based loosely on the expression levels of AT3G44720. xtrain = D[,bestpredictor] ytrain = as.numeric(D$Class) ytrain[which(xtrain&gt;11.5)]=0 ytrain[which(xtrain&lt;10)]=0 ytrain = as.factor(ytrain) xpred = Dpred[,bestpredictor] ypred = as.numeric(Dpred$Class) ypred[which(xpred&gt;11.5)]=0 ypred[which(xpred&lt;10)]=0 ypred = as.factor(ypred) Let's fit a logistic model and visualise the result: mod_fit3 &lt;- train(y ~., data=data.frame(x = xtrain, y= as.factor(ytrain)), family=&quot;binomial&quot;, method = &quot;glm&quot;) plot(xtrain,as.numeric(ytrain)-1,xlab=&quot;Marker gene&quot;,ylab=&quot;Class&quot;) lines(seq(min(xtrain),max(xtrain),length=200),predict(mod_fit3,newdata=data.frame(x = seq(min(xtrain),max(xtrain),length=200),y= matrix(200,1,1)),type=&quot;prob&quot;)[,2]) mod_fit3$results$Accuracy ## [1] 0.6575513 We can see from the plot that the model fit is very poor. However, if we look at the accuracy (printed at the bottom) the result appears to be good. This is due to the skewed number of samples from each class: there are far more uninfected samples than there are infected, which means that if the model predicts uninfected for every instance, it will be correct more than it's incorrect. We can similarly check the result on our test dataset: prob&lt;-predict(mod_fit3, newdata=data.frame(x =xpred, y = as.factor(ypred)), type=&quot;prob&quot;) pred &lt;- prediction(prob[,2], ypred) perf &lt;- performance(pred, measure = &quot;tpr&quot;, x.measure = &quot;fpr&quot;) auc &lt;- performance(pred, measure = &quot;auc&quot;) auc &lt;- auc@y.values[[1]] auc ## [1] 0.978836 These results indicates two key issues. Class imbalance can be a particular problem in regression approaches, and it is important to monitor this on a practical level. Things that we can do, depending on the dataset and method, include up-weighting the less frequently sampled class, or discarding more of the dominant class. Other metrics may also be more appropriate that AUC when classes are highly unbalanced, including area under precision-recall curves. Secondly, nonlinearities in a dataset can be problematic for both linear regression and logistic regression, and a variety of approaches exist for tackling such problems under the umbrella term of nonlinear regression. 4.2 Resources A variety of examples using {caret} to perform regression and classification have been implemented here. For those that want to start their own reading on nonlinear regression, a good stating point is Rasmussen and William's book on Gaussian processes. Be warned, it will contain a lot more maths than this course. ======= ## Exercises Solutions to exercises can be found in appendix 6. References "],
["mlnn.html", "5 Deep Learning 5.1 Multilayer Neural Networks 5.2 Convolutional neural networks 5.3 Further reading", " 5 Deep Learning 5.1 Multilayer Neural Networks Neural networks with multiple layers are increasingly used to attack a variety of complex problems in biology under the umbrella of deep learning (Angermueller and Stegle 2016,Mohammad Lotfollahi (2019)). This umbrella contains an incredibly diverse range of techniques, including densely connected networks (which are essentially complex counterparts to the traditional perceptron), convolutional neural networks (CNN), autoencoders (AE), and adversarial neural networks (ANN), amongst others. In this section we will explore the basics of deep learning on a practical level. We will first learn how to construct a neural network using {KerasR}. We will first use densely connected neural networks to explore a regression setting, before trying our hand at image classification using a set of images taken from the animated TV series Rick and Morty. For those unfamiliar with Rick and Morty, the series revolves around the adventures of Rick Sanchez, an alcoholic, arguably sociopathic scientist, and his neurotic grandson, Morty Smith. Although many scientists aspire to be like Rick, they're usually more like a Jerry. Our motivating goal in this latte section is to develop an image classification algorithm capable of telling us whether any given image contains Rick or not: a binary classification task with two classes, Rick or not Rick. For training purposes I have downloaded several thousand random images of Rick and several thousand images without Rick from the website Master of All Science. The main ideas to take home from this section are: Look at the data. There are a limitless variety of architectures that can be built into a neural network. Picking one to use is often arbitrary or at best empirically-motivated by previous works. Some approaches are better suited for specific datasets. 5.1.1 Installing the R wrapper for Keras Before we get to our main task, we will first have a go at building simple densely connected Neural Networks (NN) to perform regression. In general the nature of the NN we use will be motivated by the dataset we have and the question we're interested in. As a gentle intoduction, we aim to use NNs to calculate the square root of a number. We first generate training and evaluation dataset. For installation instructions of the Tensorflow backend please see Section X. To set the version of Python we will be using we will need to install reticulate: install.packages(reticulate) In my case, I have installed Tensorflow within Python3.9, and can set R to call this version using reticulate. library(ggplot2) library(reticulate) ## Warning: package &#39;reticulate&#39; was built under R version 3.5.2 use_python(&quot;Python3.9&quot;) If you have not already done so, you can install the keras wrapper for R via: Once tensorflow is installed and available, should be able to install the keras wrapper for R. install.packages(keras) We are now ready to begin. 5.1.2 Regression with Keras For the training set we generate two arrays, an input array, containing a random set of numbers (between \\(0\\) and \\(100\\)), and an output array, containing the square roots of those numbers (a similar set will be independently generated for the test set): library(keras) library(jpeg) ## Warning: package &#39;jpeg&#39; was built under R version 3.5.2 library(grid) set.seed(12345) tdims &lt;- 50 #Number of samples to generate x &lt;- runif(tdims, min=0, max=100) #Generate random x in range 0 to 100 y &lt;- sqrt(x) #Calculate square root of x trainingX &lt;- array(0, dim=c(tdims,1)) #Store data as an array (required by Keras) trainingX[1:tdims,1] &lt;- x trainingY &lt;- array(0, dim=c(tdims,1)) trainingY[1:tdims,1] &lt;- y #Now do the same but for a independently generated test set x &lt;- runif(tdims, min=0, max=100) y &lt;- sqrt(x) testingX &lt;- array(0, dim=c(tdims,1)) #Store as arrays testingX[1:tdims,1] &lt;- x testingY &lt;- array(0, dim=c(tdims,1)) testingY[1:tdims,1] &lt;- y A user friendly package for neural networks is available via keras, an application programming interface (API) written in Python, which uses either theano or tensorflow as a back-end. An R interface for keras is available in the form of keras. Before we can use {keras in R} we first need to load the {keras} library in R (prior to this we also have to install python package {keras} and {tensorflow}). And so we come to specifying the model itself. Keras has an simple and intuitive way of specifying layers of a neural network, and kerasR makes good use of this. We first initialise the model: model &lt;- keras_model_sequential() This tells keras that we're using the Sequential API i.e., a network with the first layer connected to the second, the second to the third and so forth, which distinguishes it from more complex networks possible using the Model API. Once we've specified a sequential model, we can start adding layers to the neural network. A standard layer of neurons, can be specified using the {Dense} command: the first layer of our network must also include the dimension of the input data. So, for example, if our input data was a scalar, we could add an input layer via: model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(1)) We also need to specify the activation function to the next level. This can be done via {activation}, so our snippet of code using a Rectified Linear Unit (relu) activation would look something like: model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(1)) %&gt;% layer_dense(units = 100, activation = &quot;relu&quot;) This is all we need to specify a single layer of the neural network. We could add another layer of \\(120\\) neurons via: model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(1)) %&gt;% layer_dense(units = 100, activation = &quot;relu&quot;) %&gt;% layer_dense(units = 120, activation = &quot;relu&quot;) Finally, we should add the output neurons. The number of output neurons will differ, but should match the size of the output we're aiming to predict. In this section we have one output, a scalar representing the square root of the input, so will have a {Dense(1)} output. The final activation function also depends on the nature of our data. If, for example, we're doing regression, we can explicitly specify a {linear} activation function. Our final model would look like: model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(1)) %&gt;% layer_dense(units = 100, activation = &quot;relu&quot;) %&gt;% layer_dense(units = 120, activation = &quot;relu&quot;) %&gt;% layer_dense(1, activation = &quot;linear&quot;) That's it. Simple! Next, we can print a summary of the network, to visualise how many parameters it has: summary(model) Before we can perform inference, we need to compile and run the model. In this case we need to specify three things: A loss function, which specifies the objective function that the model will try to minimise. A number of existing loss functions are built into keras, including the mean squared error (mean_squared_error) for regression, and categorical cross entropy (categorical_crossentropy), which is used for categorical classification. Since we are dealing with regression, we will stick with the mean squared error. An optimiser, which determines how the loss function is optimised. Possible examples include stochastic gradient descent ({SGD()}) and Root Mean Square Propagation ({RMSprop()}). A list of metrics to return. These are additional summary statistics that keras evaluates and prints. For classification, a good choice would be accuracy (or {binary_accuracy}). We can compile our model using {keras_compile}: model %&gt;% compile(loss = &quot;mse&quot;, optimizer = &quot;adam&quot;, metrics = &quot;mse&quot;) Finally the model can be fitted to the data. When doing so we additionally should specify the validation set (if we have one), the batch size, and the number of epochs, where an epoch is one forward pass and one backward pass of all the training examples, and the batch size is the number of training examples in one forward/backward pass. Our complete code would then look like this: model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(1)) %&gt;% layer_dense(units = 100, activation = &quot;relu&quot;) %&gt;% layer_dense(units = 120, activation = &quot;relu&quot;) %&gt;% layer_dense(1, activation = &quot;linear&quot;) ## Loaded Tensorflow version 2.7.0 model %&gt;% compile(loss = &quot;mse&quot;, optimizer = &quot;adam&quot;, metrics = &quot;mse&quot;) tensorflow::set_random_seed(42) model %&gt;% fit(x = trainingX, y = trainingY, validation_data = list(testingX, testingY), epochs = 100, verbose = 2) We can see that the mean square error rapidly decreases (from approx. 4 at epoch 1 to around 0.5 towards the end). As always, let's take a look at the actual results, rather than rely on summary metrics. To make predictions we can use the {predict} function: xstar &lt;- seq(0,200,by=0.5) forecastY &lt;- model %&gt;% predict(xstar) plot(xstar,forecastY,&#39;l&#39;) lines(xstar,sqrt(xstar),col=&quot;red&quot;) okay, so it's not particularly good. However, we didn't use a particularly large training set and there are a few things we can do to try to optimise the network. Another important point is that we didn't use the best network (the one with the best test set error). By default when we call prediction functions we tend to use whatever the final network was during our training. We can add this in to the code above, which would then look something like: model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(1)) %&gt;% layer_dense(units = 100, activation = &quot;relu&quot;) %&gt;% layer_dense(units = 120, activation = &quot;relu&quot;) %&gt;% layer_dense(1, activation = &quot;linear&quot;) model %&gt;% compile(loss = &quot;mse&quot;, optimizer = &quot;adam&quot;, metrics = &quot;mse&quot;) cp_callback &lt;- callback_model_checkpoint(filepath = &#39;data/RickandMorty/data/models/densemodel.h5&#39;, save_weights_only = FALSE, mode = &quot;auto&quot;, monitor = &quot;val_mse&quot;, verbose = 0) tensorflow::set_random_seed(42) model %&gt;% fit(x = trainingX, y = trainingY, validation_data = list(testingX, testingY), epochs = 100, verbose = 2, callbacks = list(cp_callback)) The optimised model can be loaded in: model = load_model_hdf5(&#39;data/RickandMorty/data/models/densemodel.h5&#39;) xstar &lt;- seq(0,200,by=0.5) forecastY &lt;- model %&gt;% predict(xstar) plot(xstar,forecastY,&#39;l&#39;) lines(xstar,sqrt(xstar),col=&quot;red&quot;) Exercise 2.1: Try varying a few other aspects of the network to get an idea of how NNs behave. For example, first try increasing the training set size. Try adding or removing layers, and varying layer widths. Another thing thing that can be varied is final layer activation. The [keras manual]{https://keras.io/api/layers/activations/} should provide a useful resource to explore what options are available. 5.1.3 Image classification with Rick and Morty We will now try to train a network for image classification. As with any machine learning application, it's important to both have some question in mind (in this case &quot;can we identify images that contain Rick Sanchez&quot;), and understand the dataset(s) we're using. The image data can be found in the directory {data/RickandMorty/data/}. We begin by loading in some images of Rick using the {readJPEG} and {grid.raster} functions. im &lt;- readJPEG(&quot;data/RickandMorty/data/AllRickImages/Rick_1.jpg&quot;) grid::grid.newpage() grid.raster(im, interpolate=FALSE, width = 0.5) Let's understand take a closer look at this dataset. We can use the funciton {dim(im)} to return the image dimensions. In this case each image is stored as a jpeg file, with \\(90 \\times 160\\) pixel resolution and \\(3\\) colour channels (RGB). This loads into R as \\(160 \\times 90 \\times 3\\) array. We could start by converting the image to grey scale, reducing the dimensions of the input data. However, each channel will potentially carry novel information, so ideally we wish to retain all of the information. You can take a look at what information is present in the different channels by plotting them individually using e.g., {grid.raster(im[,,3], interpolate=FALSE)}. Whilst the difference is not so obvious here, we can imagine sitations where different channels could be dramamtically different, for example, when dealing with remote observation data from satellites, where we might have visible wavelength alongside infrared and a variety of other spectral channels. Since we plan to retain the channel information, our input data is a tensor of dimension \\(90 \\times 160 \\times 3\\) i.e., height x width x channels. Note that this ordering is important, as the the package we're using expects this ordering (be careful, as other packages can expect a different ordering). Before building a neural network we first have to load the data and construct a training, validation, and test set of data. Whilst the package we're using has the ability to specify this on the fly, I prefer to manually seperate out training/test/validation sets, as it makes it easier to later debug when things go wrong. First load all Rick images and all not Rick images from their directory. We can get a list of all the Rick and not Rick images using {list.files}: files1 &lt;- list.files(path = &quot;data/RickandMorty/data/AllRickImages/&quot;, pattern = &quot;jpg&quot;) files2 &lt;- list.files(path = &quot;data/RickandMorty/data/AllMortyImages/&quot;, pattern = &quot;jpg&quot;) After loading the lsit of files we can see we have \\(2211\\) images of Rick and \\(3046\\) images of not Rick. Whilst this is a slightly unbiased dataset it is not dramatically so; in cases where there is extreme inbalance in the number of class observations we may have to do something extra, such as data augmentation, or assinging weights during training. We next preallocate an empty array to store these training images for the Rick and not Rick images (an array of dimension \\(5257 \\times 90 \\times 160 \\times 3\\)): allX &lt;- array(0, dim=c(length(files1)+length(files2),dim(im)[1],dim(im)[2],dim(im)[3])) We can load images using the {readJPEG} function: for (i in 1:length(files1)){ allX[i,1:dim(im)[1],1:dim(im)[2],1:dim(im)[3]] &lt;- readJPEG(paste(&quot;data/RickandMorty/data/AllRickImages/&quot;, files1[i], sep=&quot;&quot;)) } Similarly, we can load the not Rick images and store in the same array: for (i in 1:length(files2)){ allX[i+length(files1),1:dim(im)[1],1:dim(im)[2],1:dim(im)[3]] &lt;- readJPEG(paste(&quot;data/RickandMorty/data/AllMortyImages/&quot;, files2[i], sep=&quot;&quot;)) } Next we can construct a vector of length \\(5257\\) containing the classification for each of the images e.g., a \\(0\\) if the image is a Rick and \\(1\\) if it is not Rick. This is simple enough using the function {rbind}, as we know the first \\(2211\\) images were Rick and the second lot of images are not Rick. Since we are dealing with a classification algorithm, we next convert the data to binary categorical output (that is, a Rick is now represented as \\([1, 0]\\) and a not Rick is a \\([0, 1]\\)), which we can do using the {to_categorical} conversion function: labels &lt;- rbind(matrix(0, length(files1), 1), matrix(1, length(files2), 1)) allY &lt;- to_categorical(labels, num_classes = 2) Obviously in the snippet of code above we have \\(2\\) classes; we could just as easily perform classificaiton with more than \\(2\\) classes, for example if we wanted to classify Ricky, Morty, or Jerry, and so forth. We must now split our data in training sets, validation sets, and test sets. In fact I have already stored some seperate &quot;test&quot; set images in another folder that we will load in at the end, so here we only need to seperate images into training and validation sets. It's important to note that we shouldn't simply take the first \\(N\\) images for training with the remainder used for validation/testing, since this may introduce artefacts. For example, here we've loaded in all the Rick images in first, with the not Rick images loaded in second: if we took, say, the first \\(2000\\) images for training, we would be training with only Rick images, which makes our task impossible, and our algorithm will fail catastrophically. Although there are more elegant ways to shuffle data using {caret}, here we are going to manually randomly permute the data, and then take the first \\(4000\\) permuted images for training, with the remainder for validation (Note: it's crucial to permute the \\(Y\\) data in the same way). set.seed(12345) #Set random number generator for R aspects of the session vecInd &lt;- seq(0,length(files1)+length(files2)) #A vector of indexes trainInd &lt;- sample(vecInd)[1:4001] #Permute and take first 4000 training valInd &lt;- setdiff(vecInd,trainInd) #The remainder are for val/testing trainX &lt;- allX[trainInd, , , ] trainY &lt;- allY[trainInd, 1] valX &lt;- allX[valInd, , , ] valY &lt;- allY[valInd, 1] Before we move on, take a moment to think about the form of our data, in particular the output data Y. What exactly is the format we've settled on? This will be important later on in specifying our loss function. Think about cases where using similar datasets, we might want the data in a slightly different format. We are almost ready to begin building our neural networks. First can try a few things to make sure out data has been processed correctly. For example, try manually plotting several of the images and seeing if the labels are correct. Manually print out the image matrix (not a visualisation of it): think about the range of the data, and whether it will need normalising. Finally we can check to see how many of each class is in the training and validation datasets. In this case there are \\(1706\\) images of Rick and \\(2294\\) images of not Rick in the training dataset. Again, whilst there is some slight class inbalance it is not terrible, so we don't need to perform data augmentation or assign weights to the different classes during training. 5.1.4 Rick and Morty classifier using Deep Learning Let us return to our example of image classification. We start by specifying a sequential network as before. model &lt;- keras_model_sequential() %&gt;% Our data is slightly different to the usual inputs we've been dealing with: that is, we're not dealing with an input vector, but instead have an array. In this case each image is a \\(90 \\times 160 \\time 3\\) array. So for our first layer we first have to flatten this down using {flatten}: model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(90,160,3)) This should turn our \\(90 \\times \\160 \\times 3\\) input into a \\(1 \\times 43200\\) node input. We now add intermediate layers connected to the input layer with rectified linear units ({relu}) as before. model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(90,160,3)) %&gt;% layer_dense(units = 100, activation = &quot;relu&quot;) %&gt;% layer_dense(units = 70, activation = &quot;relu&quot;) Finally we connect this layer over the final output layer (two neurons) with sigmoid activation: activation layer_flatten(input_shape = c(NULL,90,160,3) , activation = &#39;relu&#39; ) %&gt;% layer_dense(units = 100) The complete model should look something like: model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(90,160,3)) %&gt;% layer_dense(units = 100, activation = &quot;relu&quot;) %&gt;% layer_dense(units = 70, activation = &quot;relu&quot;) %&gt;% layer_dense(1, activation = &quot;sigmoid&quot;) We can print a summary of the network, for example to see how many parameters it has: summary(model) In this case we see a total of \\(4,327,241\\) parameters. Yikes, that's a lot of parameters to tune, and not much data! Next we need to compile and run the model. In this case we need to specify the loss, optimiser, and metrics. Since we are dealing with binary classification, we will use binary cross entropy (binary_crossentropy) and for classification, a good choice of metrics would be accuracy (or {binary_accuracy}). We can compile our model using {keras_compile}: model %&gt;% compile(loss = &quot;binary_crossentropy&quot;, optimizer = &quot;adam&quot;, metrics = &quot;binary_accuracy&quot;) Finally the model can be fitted to the data. When doing so we additionally need to specify the validation set (if we have one), the batch size and the number of epochs, where an epoch is one forward pass and one backward pass of all the training examples, and the batch size is the number of training examples in one forward/backward pass. You may want to go and get a tea whilst this is running! set.seed(12345) model %&gt;% fit(x = trainX, y = trainY, validation_data = list(valX, valY), epochs = 25, verbose = 2) Together with an added callback to save the best model, our code should look something like this: model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(90,160,3)) %&gt;% layer_dense(units = 100, activation = &quot;relu&quot;) %&gt;% layer_dense(units = 70, activation = &quot;relu&quot;) %&gt;% layer_dense(1, activation = &quot;sigmoid&quot;) model %&gt;% compile(loss = &quot;binary_crossentropy&quot;, optimizer = &quot;adam&quot;, metrics = &quot;binary_accuracy&quot;) cp_callback &lt;- callback_model_checkpoint(filepath = &#39;data/RickandMorty/data/models/model.h5&#39;,save_weights_only = FALSE, mode = &quot;auto&quot;, monitor = &quot;val_binary_accuracy&quot;, verbose = 0) tensorflow::set_random_seed(42) model %&gt;% fit(x = trainX, y = trainY, validation_data = list(valX, valY), epochs = 25, batch_size=100, verbose = 2, callbacks = list(cp_callback)) As before we can load a saved model in using the {load_model_hdf5} function: model = load_model_hdf5(&#39;data/RickandMorty/data/models/model.h5&#39;) For this model we achieved an accuracy of above \\(0.68\\) on the validation dataset at epoch \\(18\\) (which had a corresponding accuracy \\(&gt;0.73\\) on the training set). Not fantastic when you consider that given the slight imbalance in the number of images in each class, a niave algorithm that always assigns the data to not Rick would achieve an accuracy of \\(0.58\\) and \\(0.57\\) in the training and validation sets respectively. It seems like we're getting nowhere fast, and need to change tactic. We need to think a little more about what the data actually is. In this case we're looking at a set of images. As Rick Sanchez can appear almost anywhere in the image, there's no reason to think that a given input node should correspond in two different images, so it's not surprising that the network did so badly, this is simply a task that a densely connected network is poor at. We need something that can extract out features from the image irregardless of where Rick is. There are approaches build precisely for image analysis that do just this: convolutional neural networks. 5.2 Convolutional neural networks Convolutional neural networks essentially scan through an image and extract out a set of feature representations. In multilayer neural networks, these features might then be passed on to deeper layer (other convolutional layers or standard neurons) which extract out higher order features, as shown in Figure 5.1. Finally, a densly connected network acts to combine features together for prediction. At least in an idealised description of what's going on. Figure 5.1: Example of a multilayer convolutional neural network In keras R we can add a convolutional layer using {layer_conv_2d} with a max pooling layer added via {layer_max_pooling_2d}. A multilayer convolutional neural network might look something like: model &lt;- keras_model_sequential() %&gt;% layer_conv_2d(input_shape = list(90,160,3), filters = 20, kernel_size = c(5,5)) %&gt;% layer_activation(&quot;relu&quot;) %&gt;% layer_max_pooling_2d(pool_size=c(2,2)) %&gt;% layer_conv_2d(filters = 20, kernel_size = c(5,5)) %&gt;% layer_activation(&quot;relu&quot;) %&gt;% layer_max_pooling_2d(pool_size=c(2,2)) %&gt;% layer_conv_2d(filters = 64, kernel_size = c(5,5)) %&gt;% layer_activation(&quot;relu&quot;) %&gt;% layer_max_pooling_2d(pool_size=c(2,2)) %&gt;% layer_flatten( ) %&gt;% layer_dense(units=100) %&gt;% layer_dropout(rate = 0.3) %&gt;% layer_dense(units=1, activation = &quot;sigmoid&quot;) cp_callback &lt;- callback_model_checkpoint(filepath = &#39;data/RickandMorty/data/models/modelCNN.h5&#39;,save_weights_only = FALSE, mode = &quot;auto&quot;, monitor = &quot;val_binary_accuracy&quot;, verbose = 0) model %&gt;% compile(loss = &quot;binary_crossentropy&quot;, optimizer = &quot;adam&quot;, metrics = &quot;binary_accuracy&quot;) tensorflow::set_random_seed(42) model %&gt;% fit(x = trainX, y = trainY, validation_data = list(valX, valY), epochs = 25, verbose = 2, callbacks = list(cp_callback)) Okay, so now we have achieved a better accuracy: we have an accuracy of \\(0.8901\\) on the validation dataset at epoch \\(18\\), with a training accuracy of \\(0.987\\). Whilst this is still not great (compared to how well a human could do on a similar task), it's accurate enough to begin making predictions and visualising the results. First load in the best model: model = load_model_hdf5(&#39;data/RickandMorty/data/models/modelCNN.h5&#39;) We can use this model to make predictions for images not present in either the training or validation datasets. We load in the new set of images, which can be found in the {predictions} subfolder: files &lt;- list.files(path = &quot;data/RickandMorty/data/predictions/&quot;,pattern = &quot;jpg&quot;) predictX &lt;- array(0,dim=c(length(files),90,160,3)) for (i in 1:length(files)){ x &lt;- readJPEG(paste(&quot;data/RickandMorty/data/predictions/&quot;, files[i],sep=&quot;&quot;)) predictX[i,1:90,1:160,1:3] &lt;- x[1:90,1:160,1:3] } A hard classification can be assigned using the {predict_classes} function, whilst the actual probability of assignment to either class can be evaluated using {predict} (this can be useful for images that might be ambiguous). probY &lt;- model %&gt;% predict(predictX) predictY &lt;-as.numeric(probY&gt;0.5) We can plot an example: choice = 13 grid::grid.newpage() if (predictY[choice]==1) { grid.raster(predictX[choice,1:90,1:160,1:3], interpolate=FALSE) grid.text(label=&#39;Rick&#39;,x = 0.4, y = 0.77,just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(fontsize=15, col=&quot;black&quot;)) } else { grid.raster(predictX[choice,1:90,1:160,1:3], interpolate=FALSE) grid.text(label=&#39;Not Rick&#39;,x = 0.4, y = 0.77,just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(fontsize=15, col=&quot;grey&quot;)) } choice = 1 grid::grid.newpage() if (predictY[choice]==1) { grid.raster(predictX[choice,1:90,1:160,1:3], interpolate=FALSE) grid.text(label=&#39;Rick&#39;,x = 0.4, y = 0.77,just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(fontsize=15, col=&quot;black&quot;)) } else { grid.raster(predictX[choice,1:90,1:160,1:3], interpolate=FALSE) grid.text(label=&#39;Not Rick&#39;,x = 0.4, y = 0.77,just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(fontsize=15, col=&quot;black&quot;)) } choice = 6 grid::grid.newpage() if (predictY[choice]==1) { grid.raster(predictX[choice,1:90,1:160,1:3], interpolate=FALSE) grid.text(label=&#39;Rick&#39;,x = 0.4, y = 0.77,just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(fontsize=15, col=&quot;black&quot;)) } else { grid.raster(predictX[choice,1:90,1:160,1:3], interpolate=FALSE) grid.text(label=&#39;Not Rick&#39;,x = 0.4, y = 0.77,just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(fontsize=15, col=&quot;black&quot;)) } grid::grid.newpage() choice = 16 if (predictY[choice]==1) { grid.raster(predictX[choice,1:90,1:160,1:3], interpolate=FALSE) grid.text(label=&#39;Rick&#39;,x = 0.4, y = 0.77,just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(fontsize=15, col=&quot;black&quot;)) } else { grid.raster(predictX[choice,1:90,1:160,1:3], interpolate=FALSE) grid.text(label=&#39;Not Rick: must be a Jerry&#39;,x = 0.2, y = 0.77,just = c(&quot;left&quot;, &quot;top&quot;), gp=gpar(fontsize=15, col=&quot;green&quot;)) } 5.2.1 Checking the models Although our model seems to be doing reasonably, it always helps to see where things are going wrong. Let's take a look at a few of the false positives and a few of the false negatives. probvalY &lt;- model %&gt;% predict(valX) predictvalY &lt;-as.numeric(probvalY&gt;0.5) TP &lt;- which(predictvalY==1 &amp; valY==1) FN &lt;- which(predictvalY==0 &amp; valY==1) TN &lt;- which(predictvalY==0 &amp; valY==0) FP &lt;- which(predictvalY==1 &amp; valY==0) Let's see where we go it right: grid::grid.newpage() grid.raster(valX[TP[1],1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.2) grid.raster(valX[TP[2],1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.5) grid.raster(valX[TP[3],1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.8) And wrong (false negative): grid::grid.newpage() grid.raster(valX[FN[1],1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.2) grid.raster(valX[FN[2],1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.5) grid.raster(valX[FN[3],1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.8) Or false positives: grid::grid.newpage() grid.raster(valX[FP[1],1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.2) grid.raster(valX[FP[2],1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.5) grid.raster(valX[FP[4],1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.8) It's not entirely clear why exactly the network is failing in some of these cases. An alternative way to look at what's going wrong is a look at which pixels are contributing the most to the classifier, as we have done during the lecture. Currently this can be done in Python implementations of Keras using the [DeepExplain]{https://github.com/marcoancona/DeepExplain} package {M. Ancona and Grosss (2018)}. Example Python code for doing this has been provided in the {Python} subdirectory. 5.2.2 Data augmentation Although we saw some improvements when using convolutional neural networks compared to densely connected one, the end results were not particularly convincing. After all, previous applications in the recognition of handwritten digits (0-9) showed above human accuracy, see e.g., Neural Networks and Deep Learning. Our accuracy of approximately \\(90\\) percent is nowhere near human levels. So where are we gong wrong? We should, of course, start by considering the number of parameters versus the size of the training dataset. In our final model we had \\(69,506\\) parameters, and only a few thousand training images, so it is perhaps not surprising that our model is doing relatively poorly. In previous examples of digit recognition more than \\(10,000\\) images were used, whilst better known examples of deep learning for image classification make use of millions of images. Our task is also, arguably, a lot harder than digit recognition. After all, a handwritten \\(0\\) is relatively similar regardless of who wrote it. Rick Sanchez, on the other hand, can come in a diverse range of guises, with different postures, facial expressions, clothing, and even in pickle-Rick form. We may well need a vastly increased number of training images: with more training data, we can begin to learn more robustly what features define a Rick. Whilst we could simply download more data from Master of All Science, an alternative approach is to artificially increase our pool of training data by manipulating the images. For example, we could shear, warp or rotate some of the images in our training set; we could add noise and we could manipulate the colouring. 5.2.3 Asking more precise questions Another way we could improve our accuracy is to ask more precise questions. In our application we have focused on what makes a Rick, and what makes a not Rick. Whilst there may be definable features for Rick, such as his hair and his white coat, the class not Rick is an amalgamation of all other characters and scenes in the series. A more specific approach might be to develop algorithms that classify Rick versus Morty. In this case additionally learning the features of a Morty might make it easier to make a binary choice. Of course, we might want to allow more complex situations, such as case where you have a Rick and a Morty. As a general open question, think about how you would encode just such an example. What would you need to change in the code? Another approach that might help us increase our accuracy is to use transfer learning. This is where we make use of existing neural networks to make predictions about our specific datasets, usually by fixing the topology and parameters of the uppermost layers and fine tuning the lower layers to our dataset. For image recognition we could make use of top perfoming neural networks on the ImageNet database, although these types of large-scale models are certainly not without their issues {Prabhu and Birhane (2020)}. Whilst none of these networks would have been designed to identify Rick they would have been trained on millions of images, and the top levels would have been able to extract useful general features of that allowed identification of images. 5.2.4 More complex networks More complex learning algorithms can easily be built using Keras via the model class API. This allows, for example, learning from multiple inputs and/or predicting multiple outputs, with more interconnection between the different layers. We might, for example, want to include additional contextual information about the image that could serve to augment the predictions. 5.2.5 Autoencoders In previous sections we have used CNNs to build a Rick/not Rick classifier. In doing so we are halfway towards other interesting neural network architectures, including autoencoders. One type of autoencoder consists of a stack of convolution/max pooling layers which served to condense the original image down into a reduced dimensional (encoded) representation, with a stack of upsampled layers used to decode the encoded layer (Figure 5.2). Within such a network the input and output layers are an identical image and we are therefore training a network that can both compresses the original high resolution data and subsequently interpret that compressed representation to recreate the original as closely as possible. A slight deviation of this principle would be to use noisy versions of the image as input, with clean versions as the output. In these cases the autoencoder becomes a denoiser (Figure 5.3). Similar methods can be used for generating higher resolution versions of an image. Figure 5.2: Example of an autoencoder (https://towardsdatascience.com/generating-images-with-autoencoders-77fd3a8dd368) Figure 5.3: Example of an autoencoder (https://towardsdatascience.com/generating-images-with-autoencoders-77fd3a8dd368) In the example below we implement a simple Autoencoder, constructed by stacking a number of convolution layers with a stak of deconvolution layers (foregoing the max pooling layers). Note that in, in R, each pixel is represented as a number between 1 and 0. A suitable final activation function is therefore one that scales between 0 and 1 e.g., a sigmoid function. Nevertheless, we are not doing logistic regrssion, so we will choose to monitor the mse. Note that this snippet of code will take a good few hours to run \\(25\\) epochs. model &lt;- keras_model_sequential() %&gt;% layer_conv_2d(input_shape = list(90,160,3), filters = 20, kernel_size = c(5,5)) %&gt;% layer_activation(&quot;relu&quot;) %&gt;% layer_conv_2d(filters = 20, kernel_size = c(5,5)) %&gt;% layer_activation(&quot;relu&quot;) %&gt;% layer_conv_2d(filters = 64, kernel_size = c(5,5)) %&gt;% layer_activation(&quot;relu&quot;) %&gt;% layer_conv_2d_transpose(filters = 64, kernel_size = c(5,5)) %&gt;% layer_activation(&quot;relu&quot;) %&gt;% layer_conv_2d_transpose(filters = 20, kernel_size = c(5,5)) %&gt;% layer_activation(&quot;relu&quot;) %&gt;% layer_conv_2d_transpose(filters = 20, kernel_size = c(5,5)) %&gt;% layer_activation(&quot;relu&quot;) %&gt;% layer_conv_2d(filters = 3, kernel_size = c(5,5), padding = &#39;same&#39;) %&gt;% layer_activation(&quot;sigmoid&quot;) cp_callback &lt;- callback_model_checkpoint(filepath = &#39;data/RickandMorty/data/models/modelAE.h5&#39;,save_weights_only = FALSE, mode = &quot;auto&quot;, monitor = &quot;val_mse&quot;, verbose = 0) model %&gt;% compile(loss = &quot;binary_crossentropy&quot;, optimizer = &quot;adam&quot;, metrics = &quot;mse&quot;) tensorflow::set_random_seed(42) model %&gt;% fit(x = trainX, y = trainX, validation_data = list(valX, valX), epochs = 25, verbose = 2, callbacks = list(cp_callback)) Instead of running this snippet again, we can load in a pre-run model. model = load_model_hdf5(&#39;data/RickandMorty/data/models/modelAE.h5&#39;) summary(model) We can see that this model condenses down the images from \\(90 \\times 160\\) pixel images down to \\(78 \\times 148\\) (not a huge compression, but a good starting point). Let's try compressing (and decompressing) a few of the held out examples: predictAEX &lt;- model %&gt;% predict(predictX) grid::grid.newpage() grid.raster(predictX[1,1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.2) grid.raster(predictAEX[1,1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.5) grid::grid.newpage() grid.raster(predictX[2,1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.2) grid.raster(predictAEX[2,1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.5) grid::grid.newpage() grid.raster(predictX[3,1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.2) grid.raster(predictAEX[3,1:90,1:160,1:3], interpolate=FALSE, width = 0.3, x = 0.5, y=0.5) Exercise 2.2: Think about how the script can be modified to demonstrate the use of a denoisiny algorithm (hint: the dataset will need to be modified in some way, but the algorithm itself should be functional as is). 5.3 Further reading A particularly comprehensive introduction to Deep Learning can be found in the e-book Neural Networks and Deep Learning, written by Michael Nielsen. Useful examples can also be found in the keras documentation, with many more examples found in the keras R wrapper documentation. ======= ## Exercises Solutions to exercises can be found in appendix 6. References "],
["solutions-logistic-regression.html", "6 Solutions to Chapter 4 - Linear regression and logistic regression", " 6 Solutions to Chapter 4 - Linear regression and logistic regression Solutions to exercises of chapter 4. Exercise 1.1. Before we begin, we first need to visualise the data as a whole. Heatmaps are one way of looking at large datasets. Since we're looking for differences I will make a heatmap of the difference between control and infected at each time point and subcluster by pattern: #install.packages(&quot;pheatmap&quot;) library(pheatmap) DeltaVals &lt;- t(D[25:48,3:164] - D[1:24,3:164]) pheatmap(DeltaVals, cluster_cols = FALSE, cluster_rows = TRUE) we can see a number of rows in which there appears to be large scale changes as the time series progresses. Going forward we can pick one where this is particularly strong. Exercise 1.1. We can systematically fit a model with increasing degree and evaluate/plot the RMSE on the held out data. RMSE &lt;- rep(NULL, 10) lrfit1 &lt;- train(y~poly(x,degree=1), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[1] &lt;- lrfit1$results$RMSE lrfit2 &lt;- train(y~poly(x,degree=2), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[2] &lt;- lrfit2$results$RMSE lrfit3 &lt;- train(y~poly(x,degree=3), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[3] &lt;- lrfit3$results$RMSE lrfit4 &lt;- train(y~poly(x,degree=4), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[4] &lt;- lrfit4$results$RMSE lrfit5 &lt;- train(y~poly(x,degree=5), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[5] &lt;- lrfit5$results$RMSE lrfit6 &lt;- train(y~poly(x,degree=6), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[6] &lt;- lrfit6$results$RMSE lrfit7 &lt;- train(y~poly(x,degree=7), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[7] &lt;- lrfit7$results$RMSE lrfit8 &lt;- train(y~poly(x,degree=8), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[8] &lt;- lrfit8$results$RMSE lrfit9 &lt;- train(y~poly(x,degree=9), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[9] &lt;- lrfit9$results$RMSE lrfit10 &lt;- train(y~poly(x,degree=10), data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) RMSE[10] &lt;- lrfit10$results$RMSE plot(RMSE) plot(RMSE[1:5]) From these plots it looks like the best model is one with degree \\(d=2\\) or \\(d=4\\), suggesting there is a lot more complexity to this gene. You can clean the code up to make it run in a loop. Hint: you can not directly pass a variable over to poly (y~poly(x,i) will not work) and will have to convert to a function: setdegree &lt;- 5 f &lt;- bquote( y~poly(x,degree=.(setdegree) ) ) lrfit11 &lt;- train( as.formula(f) , data=data.frame(x=D[1:24,1],y=D[1:24,geneindex]), method = &quot;lm&quot;) "],
["solutions-to-chapter-5-neural-networks.html", "7 Solutions to Chapter 5 - Neural Networks", " 7 Solutions to Chapter 5 - Neural Networks Excersie 2.1: We increase the training size and tweak network structure in various ways. tdims &lt;- 5000 #Number of samples to generate x &lt;- runif(tdims, min=0, max=100) #Generate random x in range 0 to 100 y &lt;- sqrt(x) #Calculate square root of x trainingX &lt;- array(0, dim=c(tdims,1)) #Store data as an array (required by Keras) trainingX[1:tdims,1] &lt;- x trainingY &lt;- array(0, dim=c(tdims,1)) trainingY[1:tdims,1] &lt;- y #Now do the same but for a independently generated test set x &lt;- runif(tdims, min=0, max=100) y &lt;- sqrt(x) testingX &lt;- array(0, dim=c(tdims,1)) #Store as arrays testingX[1:tdims,1] &lt;- x testingY &lt;- array(0, dim=c(tdims,1)) testingY[1:tdims,1] &lt;- y model &lt;- keras_model_sequential() %&gt;% layer_flatten(input_shape = c(1)) %&gt;% layer_dense(units = 10, activation = &quot;relu&quot;) %&gt;% layer_dense(units = 20, activation = &quot;relu&quot;) %&gt;% layer_dense(1, activation = &quot;linear&quot;) model %&gt;% compile(loss = &quot;mse&quot;, optimizer = &quot;adam&quot;, metrics = &quot;mse&quot;) cp_callback &lt;- callback_model_checkpoint(filepath = &#39;data/RickandMorty/data/models/densemodel.h5&#39;, save_weights_only = FALSE, mode = &quot;auto&quot;, monitor = &quot;val_mse&quot;, verbose = 0) tensorflow::set_random_seed(42) model %&gt;% fit(x = trainingX, y = trainingY, validation_data = list(testingX, testingY), epochs = 100, verbose = 2, callbacks = list(cp_callback)) model = load_model_hdf5(&#39;data/RickandMorty/data/models/densemodel.h5&#39;) xstar &lt;- seq(0,200,by=0.5) forecastY &lt;- model %&gt;% predict(xstar) plot(xstar,forecastY,&#39;l&#39;) lines(xstar,sqrt(xstar),col=&quot;red&quot;) For comparison we can also use linear regression to compare our predictions: colnames(trainingX) &lt;- &quot;x&quot; colnames(trainingY) &lt;- &quot;y&quot; lrfit &lt;- lm(y~x) newd &lt;- data.frame(x=newX) predictedValues&lt;-predict.lm(lrfit, newdata = newd) lines(newX,predictedValues, col=&quot;red&quot;) Excercsie 2.1: The network architecture should be fine for this task. However a noisy version of the input data will have to be generated (e.g., by setting a random set of pixels to zero) to be passed in to the AE. A clean version of the data should be retained and passed to the AE as the output. As a final model I have included a modification of a variational autoencoder on the Rick and Morty dataset based on the one here K &lt;- keras::backend() # input image dimensions and other parameters img_rows &lt;- 90L img_cols &lt;- 160L img_chns &lt;- 3L filters &lt;- 64L num_conv &lt;- 3L latent_dim &lt;- 2L intermediate_dim &lt;- 128L epsilon_std &lt;- 1.0 batch_size &lt;- 100L epochs &lt;- 5L original_img_size &lt;- c(img_rows, img_cols, img_chns) x &lt;- layer_input(shape = c(original_img_size)) conv_1 &lt;- layer_conv_2d(x, filters = img_chns, kernel_size = c(2L, 2L), strides = c(1L, 1L), padding = &quot;same&quot;, activation = &quot;relu&quot;) conv_2 &lt;- layer_conv_2d(conv_1, filters = filters, kernel_size = c(2L, 2L), strides = c(2L, 2L), padding = &quot;same&quot;, activation = &quot;relu&quot;) conv_3 &lt;- layer_conv_2d(conv_2, filters = filters, kernel_size = c(num_conv, num_conv), strides = c(1L, 1L), padding = &quot;same&quot;, activation = &quot;relu&quot;) conv_4 &lt;- layer_conv_2d(conv_3, filters = filters, kernel_size = c(num_conv, num_conv), strides = c(1L, 1L), padding = &quot;same&quot;, activation = &quot;relu&quot;) flat &lt;- layer_flatten(conv_4) hidden &lt;- layer_dense(flat, units = intermediate_dim, activation = &quot;relu&quot;) z_mean &lt;- layer_dense(hidden, units = latent_dim) z_log_var &lt;- layer_dense(hidden, units = latent_dim) sampling &lt;- function(args) { z_mean &lt;- args[, 1:(latent_dim)] z_log_var &lt;- args[, (latent_dim + 1):(2 * latent_dim)] epsilon &lt;- k_random_normal( shape = c(k_shape(z_mean)[[1]]), mean = 0., stddev = epsilon_std ) z_mean + k_exp(z_log_var) * epsilon } z &lt;- layer_concatenate(list(z_mean, z_log_var)) %&gt;% layer_lambda(sampling) output_shape &lt;- c(batch_size, 45L, 80L, filters) decoder_hidden &lt;- layer_dense(units = intermediate_dim, activation = &quot;relu&quot;) decoder_upsample &lt;- layer_dense(units = prod(output_shape[-1]), activation = &quot;relu&quot;) decoder_reshape &lt;- layer_reshape(target_shape = output_shape[-1]) decoder_deconv_1 &lt;- layer_conv_2d_transpose(filters = filters,kernel_size = c(num_conv, num_conv),strides = c(1L, 1L),padding = &quot;same&quot;,activation = &quot;relu&quot;) decoder_deconv_2 &lt;- layer_conv_2d_transpose(filters = filters,kernel_size = c(num_conv, num_conv),strides = c(1L, 1L),padding = &quot;same&quot;,activation = &quot;relu&quot;) decoder_deconv_3_upsample &lt;- layer_conv_2d_transpose(filters = filters,kernel_size = c(3L, 3L),strides = c(2L, 2L),padding = &quot;valid&quot;,activation = &quot;relu&quot;) decoder_mean_squash &lt;- layer_conv_2d(filters = img_chns,kernel_size = c(2L, 2L),strides = c(1L, 1L),padding = &quot;valid&quot;,activation = &quot;sigmoid&quot;) hidden_decoded &lt;- decoder_hidden(z) up_decoded &lt;- decoder_upsample(hidden_decoded) reshape_decoded &lt;- decoder_reshape(up_decoded) deconv_1_decoded &lt;- decoder_deconv_1(reshape_decoded) deconv_2_decoded &lt;- decoder_deconv_2(deconv_1_decoded) x_decoded_relu &lt;- decoder_deconv_3_upsample(deconv_2_decoded) x_decoded_mean_squash &lt;- decoder_mean_squash(x_decoded_relu) # custom loss function vae_loss &lt;- function(x, x_decoded_mean_squash) { x &lt;- k_flatten(x) x_decoded_mean_squash &lt;- k_flatten(x_decoded_mean_squash) xent_loss &lt;- 1.0 * img_rows * img_cols * loss_binary_crossentropy(x, x_decoded_mean_squash) kl_loss &lt;- -0.5 * k_mean(1 + z_log_var - k_square(z_mean) - k_exp(z_log_var), axis = -1L) k_mean(xent_loss + kl_loss) } ## variational autoencoder vae &lt;- keras_model(x, x_decoded_mean_squash) vae %&gt;% compile(optimizer = &quot;rmsprop&quot;, loss = vae_loss) summary(vae) ## encoder: model to project inputs on the latent space encoder &lt;- keras_model(x, z_mean) ## build a digit generator that can sample from the learned distribution gen_decoder_input &lt;- layer_input(shape = latent_dim) gen_hidden_decoded &lt;- decoder_hidden(gen_decoder_input) gen_up_decoded &lt;- decoder_upsample(gen_hidden_decoded) gen_reshape_decoded &lt;- decoder_reshape(gen_up_decoded) gen_deconv_1_decoded &lt;- decoder_deconv_1(gen_reshape_decoded) gen_deconv_2_decoded &lt;- decoder_deconv_2(gen_deconv_1_decoded) gen_x_decoded_relu &lt;- decoder_deconv_3_upsample(gen_deconv_2_decoded) gen_x_decoded_mean_squash &lt;- decoder_mean_squash(gen_x_decoded_relu) generator &lt;- keras_model(gen_decoder_input, gen_x_decoded_mean_squash) vae %&gt;% fit(trainX, trainX, shuffle = TRUE, epochs = epochs, batch_size = batch_size, validation_data = list(valX, valX)) Which we can visualise: ## display a 2D plot of the digit classes in the latent space x_test_encoded &lt;- predict(encoder, x_test, batch_size = batch_size) x_test_encoded %&gt;% as_data_frame() %&gt;% mutate(class = as.factor(mnist$test$y)) %&gt;% ggplot(aes(x = V1, y = V2, colour = class)) + geom_point() ## display a 2D manifold of the digits n &lt;- 15 # figure with 15x15 digits digit_size &lt;- 28 # we will sample n points within [-4, 4] standard deviations grid_x &lt;- seq(-4, 4, length.out = n) grid_y &lt;- seq(-4, 4, length.out = n) rows &lt;- NULL for(i in 1:length(grid_x)){ column &lt;- NULL for(j in 1:length(grid_y)){ z_sample &lt;- matrix(c(grid_x[i], grid_y[j]), ncol = 2) column &lt;- rbind(column, predict(generator, z_sample) %&gt;% matrix(ncol = digit_size)) } rows &lt;- cbind(rows, column) } rows %&gt;% as.raster() %&gt;% plot() "]
]
